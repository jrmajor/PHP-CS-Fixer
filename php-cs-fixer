#!/usr/bin/env php
<?php

/*
 * This file is part of PHP CS Fixer.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *     Dariusz Rumi≈Ñski <dariusz.ruminski@gmail.com>
 *
 * This source file is subject to the MIT license that is bundled
 * with this source code in the file LICENSE.
 */

error_reporting(E_ALL & ~E_DEPRECATED & ~E_USER_DEPRECATED);

set_error_handler(static function ($severity, $message, $file, $line) {
    if ($severity & error_reporting()) {
        throw new ErrorException($message, 0, $severity, $file, $line);
    }
});

// check environment requirements
(function () {
    if (\PHP_VERSION_ID === 80000) {
        fwrite(STDERR, "PHP CS Fixer is not able run on PHP 8.0.0 due to bug in PHP tokenizer (https://bugs.php.net/bug.php?id=80462).\n");
        fwrite(STDERR, "Update PHP version to unblock execution.\n");

        exit(1);
    }

    if (\PHP_VERSION_ID < 70400 || \PHP_VERSION_ID >= 80200) {
        fwrite(STDERR, "PHP needs to be a minimum version of PHP 7.4.0 and maximum version of PHP 8.1.*.\n");
        fwrite(STDERR, 'Current PHP version: '.PHP_VERSION.".\n");

        if (getenv('PHP_CS_FIXER_IGNORE_ENV')) {
            fwrite(STDERR, "Ignoring environment requirements because `PHP_CS_FIXER_IGNORE_ENV` is set. Execution may be unstable.\n");
        } else {
            fwrite(STDERR, "To ignore this requirement please set `PHP_CS_FIXER_IGNORE_ENV`.\n");
            fwrite(STDERR, "If you use PHP version higher than supported, you may experience code modified in a wrong way.\n");
            fwrite(STDERR, "Please report such cases at https://github.com/FriendsOfPHP/PHP-CS-Fixer .\n");

            exit(1);
        }
    }

    foreach (['json', 'tokenizer'] as $extension) {
        if (!extension_loaded($extension)) {
            fwrite(STDERR, sprintf("PHP extension ext-%s is missing from your system. Install or enable it.\n", $extension));

            if (getenv('PHP_CS_FIXER_IGNORE_ENV')) {
                fwrite(STDERR, "Ignoring environment requirements because `PHP_CS_FIXER_IGNORE_ENV` is set. Execution may be unstable.\n");
            } else {
                exit(1);
            }
        }
    }
})();

const __PHP_CS_FIXER_RUNNING__ = true;

// load dependencies
(function () {
    require_once __DIR__.'/vendor/autoload.php';

    (function () {
        $unscopedFilesToBeLoaded = [
            md5('symfony/polyfill-ctype:bootstrap.php') => true,
            md5('symfony/polyfill-intl-grapheme:bootstrap.php') => true,
            md5('symfony/polyfill-intl-normalizer:bootstrap.php') => true,
            md5('symfony/polyfill-mbstring:bootstrap.php') => true,
            md5('symfony/polyfill-php73:bootstrap.php') => true,
            md5('symfony/polyfill-php80:bootstrap.php') => true,
            md5('symfony/polyfill-php81:bootstrap.php') => true,
        ];

        $loadedUnscopedFiles = array_intersect_key(
            $unscopedFilesToBeLoaded,
            $GLOBALS['__composer_autoload_files']
        );

        if ($loadedUnscopedFiles !== $unscopedFilesToBeLoaded) {
            exit(1);
        }

        $GLOBALS['__composer_autoload_files'] = $loadedUnscopedFiles;
    })();

    // try to load Composer autoloader for the current working directory
    (function () {
        try {
            $composerConfig = file_get_contents(getcwd().'/composer.json');
            $composerConfig = json_decode($composerConfig, true);

            $vendorDirName = $composerConfig['config']['vendor-dir'] ?? 'vendor';
            $vendorDirName = \is_string($vendorDirName) ? $vendorDirName : 'vendor';
        } catch (\Throwable $e) {
            $vendorDirName = 'vendor';
        }

        $path = getcwd().'/'.$vendorDirName.'/autoload.php';

        if (is_file($path)) {
            require_once $path;
        }
    })();

    // try to load ../../autoload.php, in case PHAR is located in a vendor directory
    (function (): void {
        $pharPath = extension_loaded('phar') ? Phar::running(false) : '';

        if ('' === $pharPath) {
            return;
        }

        $path = dirname($pharPath).'/../../autoload.php';

        if (is_file($path)) {
            require_once $path;
        }
    })();
})();

use Composer\XdebugHandler\XdebugHandler;
use PhpCsFixer\Console\Application;

// Restart if Xdebug is loaded, unless the PHP_CS_FIXER_ALLOW_XDEBUG environment variable is set.
$xdebug = new XdebugHandler('PHP_CS_FIXER');
$xdebug->check();
unset($xdebug);

$application = new Application();
$application->run();
